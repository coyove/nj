NJ is a simple script engine written in golang with Lua-like syntax.

(If you are looking for a Lua 5.2 compatible engine, refer to tag `v0.2`)

## Differ from Lua

- There is no `table`, instead there are `array` and `object` respectively:
	- `a=[1, 2, 3]`.
	- `a={a=1, b=2}`.
	- Empty array and empty object are `true` when used as booleans.
- There are `typed` array and `untyped` array:
	- Untyped arrays are generic arrays, where any values can be stored inside.
	- Typed arrays are special arrays from Go, say `[]byte`:
		- `a = str.bytes(16)` creates a 16-byte long `[]byte`.
		- `a.append(1)` appends 1 to it.
		- `a.append(true)` will panic.
		- `a.untype().append(true)` will `untype` the array into a (new) generic array.
- Functions are callable objects:
	- `function foo() end; print(type(foo))` prints `object`.
	- `function foo() end; print(foo.iscallable())` prints `true`.
- Functions should be declared in the topmost scope:
	- `do function foo() ... end end` is invalid.
	- `if true then function foo() function bar() ... end end` is invalid.
	- `function foo() function bar() ... end end` is invalid.
- Use `lambda` to declare anonymous functions:
	- `local foo = lambda(x) ... end`.
	- Last `return` can be omitted: `lambda (x) x=x+1; x end <=> lambda (x) x=x+1; return x end`.
- Syntax of calling functions strictly requires no spaces between callee and '(':
	- `print(1)` is the only right way of calling a function.
	- `print (1)` literally means two things: 1) get value of `print` and discard it, 2) evaluate `(1)`.
- To write variadic functions:
	- `function foo(a, b...) end`.
	- `args = [1, 2, 3]; foo(args...)`.
- Simple keyword arguments syntax sugar:
	- `foo(a, b=2, c=3)` will be converted to `foo(a, {b=2, c=3})`.
- Returning multiple arguments will be translated into returning an array, e.g.:
	- `function foo() return 1, 2 end <=> function foo() return [1, 2] end`.
	- `local a, b, c = d <=> local a, b, c = d[0], d[1], d[2]`.
- Everything starts at ZERO. For-loops start inclusively and end exclusively, e.g.:
	- `a=[1, 2]; assert(a[0] == 1)`.
	- `for i=0,n do ... end` ranges `[0, n-1]`.
	- `for i=n-1,-1,-1 do ... end` ranges `[n-1, 0]`.
- Every function has a `this` pointing to itself, if the function was loaded from an object, `this` will point to it instead:
	- `function foo(x) this.x = x end; foo(1); assert(foo.x, 1)`
	- `a={foo=lambda(x) this.x = x end}; a.foo(1); assert(a.x, 1)`
- You can define up to 32000 variables (varies depending on the number of temporal variables generated by interpreter) in a function.
- Numbers are `int64 + float64` internally, interpreter may promote it to `float64` when needed and downgrade it to `int64` when possible.
- You can `return` anywhere inside functions, `continue` inside for-loops, `goto` any label within the same function.

## Run

```golang
program, err := LoadString("return 1")
v, err := program.Run() // v == 1
```

### Global Values

```golang
Globals.SetProp("G", ValueOf(func() int { return 1 }))

program, _ := LoadString("return G() + 1")
v, err := program.Run() // v == 2

program, _ = LoadString("return G() + 2")
v, err = program.Run() // v == 3

program, _ = LoadString("return G + 2", &CompileOptions{
	Globals: NewObject(0).SetProp("G", 10), // override the global 'G'
})
v, err = program.Run() // v == 12
```

## Benchmarks

Refer to [here](https://github.com/coyove/potatolang/blob/master/tests/bench/perf.md).

