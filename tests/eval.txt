local env = createprototype("env", function(p)
    this.store = {}
    this.top = if(p, p.top, this)
    this.parent = p
end)

env._break = []
env._continue = []
env._return = {}

function env.set(k, v)
    this.store[k] = v
end

function env.setp(k, v)
    if this.store.hasownproperty(k) then
        this.store[k] = v
        return true
    end
    if this.parent then
        if this.parent.setp(k, v) then
            return false
        end
    end
    this.store[k] = v
    return true
end

function env.get(k)
    if k == "nil" then return nil, true end
    if k == "true" then return true, true end
    if k == "false" then return false, true end
    local v = this.store[k:self]
    if v != self then
        return v, true
    end
    if this.parent then
        return this.parent.get(k)
    end
    return nil, false
end

function runUnary(run, node, e)
    if node.Op == eval.op.ret then
        panic(new(env._return, {result=run(node.A, e)}))
    end
end

function runBinary(run, node, e)
    if node.Op == eval.op.add then
        return run(node.A, e) + run(node.B, e)
    elseif node.Op == eval.op.sub then
        return run(node.A, e) - run(node.B, e)
    elseif node.Op == eval.op.less then
        return run(node.A, e) < run(node.B, e)
    elseif node.Op == eval.op.inc then
        local res = run(node.A, e) + run(node.B, e)
        e.setp(node.A.Name, res)
        return res
    end
end

function run(node, e)
    if node is "@*parser.Prog" then
        local e2 = if(node.DoBlock, env(e), e)
        local last
        for _, stat in node.Stats do
            last = run(stat, e2) 
            if last == env._break or last == env._continue then return last end
        end
        return last
    elseif node is "@*parser.If" then
        if run(node.Cond, e) then
            res = run(node.True, env(e))
        elseif node.False then
            res = run(node.False, env(e))
        end
        return res
    elseif node is "@*parser.Loop" then
        while true do
            local res = run(node.Body, e)
            if res == env._break then break end
            if res == env._continue then 
                run(node.Continue, e)
            end
        end
    elseif node is "@*parser.And" then
        return run(node.A, e) and run(node.B, e)
    elseif node is "@*parser.Or" then
        return run(node.A, e) or run(node.B, e)
    elseif node is "@*parser.Declare" then
        e.set(node.Name.Name, run(node.Value, e))
    elseif node is "@*parser.Assign" then
        e.setp(node.Name.Name, run(node.Value, e))
    elseif node is "<@*parser.LoadConst, @*parser.Release>" then
        -- omit
    elseif node is "@parser.Primitive" then
        return node.Value()
    elseif node is "@*parser.Binary" then
        return runBinary(run, node, e)
    elseif node is "@*parser.Unary" then
        return runUnary(run, node, e)
    elseif node is "@*parser.BreakContinue" then
        return if(node.Break, env._break, env._continue)
    elseif node is "@*parser.Symbol" then
        local v, ok = e.get(node.Name)
        assert(ok, true, "unknown symbol: %v".format(node.Name))
        return v
    elseif node is "@parser.ExprList" then
        lst = []
        for _, n in node do
            lst[#lst] = run(n, e)
        end
        return lst
    elseif node is "@parser.ExprAssignList" then
        lst = {}
        for _, n in node do
            lst[run(n[0], e)] = run(n[1], e)
        end
        return lst
    elseif node is "@*parser.Call" then
        local callee = run(node.Callee, e)
        if callee is callable then
            return callee(run(node.Args, e)...)
        end
        local e2 = env(e.top)
        for i, name in callee.Args do
            e2.set(name.Name, if(i < #node.Args, run(node.Args[i], e), nil))
        end
        local res = run.try(callee.Body, e2)
        if res is error and res.error() is env._return then
            return res.error().result
        end
        return res
    elseif node is "@*parser.Function" then
        return node
    else
        local tmp = buffer()
        node.Dump(tmp)
        panic("unknown node: %v".format(tmp.value()))
    end
end

function newenv(a)
    local e = env(nil)
    e.store.merge(globals())
    e.store.merge(a)
    return e
end

function loadstring(expr, e)
    res = run.try(eval.parse(expr), e)
    if res is error and res.error() is env._return then
        return res.error().result
    end
    return res
end

local N=1e3
local res = loadstring("a=0 for i=1,%v+1 do a+=i end a".format(N), newenv(nil))
assert(res, N*(N+1)/2)

start = time()
code = [[
    function fib(n)
        if n < 2 then return n end
        return fib(n - 1) + fib(n-2)
    end
    return (fib(N))
]]
res = loadstring(code, newenv({N=20}))
assert(res, eval(code, {N=20}))
print(time() - start, ' res=', res)
